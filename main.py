from PIL import Image
from files import create_destination_file, open_source_image, write_to_destination_file
from generate_html import generate_html_start, generate_html_end


def create_hex_colour_string(red: int, green: int, blue: int) -> str:
    """
    Converts RGB into HEX

    :param red:
    :param green:
    :param blue:
    :return: string HEX code
    """
    return '%02x%02x%02x' % (red, green, blue)


def generate_hex_shortcuts(width: int, height: int, pixels):
    """
    Takes the width and height of the image as well as the PIL PixelAccess class for the image. Generates a dict of
    all unique hex codes in the image as keys, and a unique class name as values

    :param width:
    :param height:
    :param pixels: PIL PixelAccess class for the given image
    :return: Dict of hex codes as keys and class names as values
    """
    shortcut_num = 0
    hex_shortcuts = {}
    for y in range(height):  # Loop through each row of pixels
        for x in range(width):  # Loop through each column of pixels
            red, green, blue = pixels[x, y]
            hex_string = create_hex_colour_string(red, green, blue)
            if hex_string not in hex_shortcuts:  # Add all unique RGB codes to the list of shortcuts
                # Use an incrementing number for each unique RGB code encountered
                hex_shortcuts[hex_string] = 's' + str(shortcut_num)
                shortcut_num += 1
    return hex_shortcuts


def map_hex_shortcuts_to_image(img_width: int, img_height: int, img_pixels, img_rgb_shortcuts):
    """
    Maps the dict of hex shortcut classes to the image's pixels to create a list of rows.
    Each row contains the hex shortcut class for each pixel

    :param img_width:
    :param img_height:
    :param img_pixels: PIL PixelAccess class for the given image
    :param img_rgb_shortcuts: Dict of hex shortcuts generated by generate_hex_shortcuts()
    :return: 2d list of pixels represented by their hex shortcut class
    """
    mapped_shortcuts = []
    # Generate a nested list of each row in the image, containing the unique attribute for each pixel
    for y in range(img_height):  # Loop through each row of pixels
        # Add a new row into the mapped list of pixels
        mapped_shortcuts.append([])
        for x in range(img_width):  # Loop through each column of pixels
            hex_code = create_hex_colour_string(*img_pixels[x, y])
            mapped_shortcuts[y].append(img_rgb_shortcuts[hex_code])  # Get the RGB shortcut for each pixel
    return mapped_shortcuts


def generate_shortcut_css(img_hex_shortcuts: dict) -> str:
    """
    Iterate through dict of hex shortcut classes to generate the CSS needed to display
    the HTML image

    :param img_hex_shortcuts: dict of hex shortcut classes as generated by generate_hex_shortcuts()
    :return: String containing all CSS needed to display the image
    """
    css = ''
    for hex_code in img_hex_shortcuts:
        css += 'i[' + img_hex_shortcuts[hex_code] + ']{' + 'background:#' + hex_code + '}'
    return css


def generate_html_pixels(shortcuts):
    """
    Generates the 'pixels' for a given list of hex shortcuts

    :param shortcuts: 2d list of shortcut classes as generated by map_hex_shortcuts_to_image()
    :return:
    """
    html_pixels = ''
    for row in shortcuts:
        for pixel_hex in row:
            html_pixels += f"<i {pixel_hex}></i>"
    return html_pixels


print('Welcome to the Image to HTML convertor\n')
print('By Ash C\n')

img_path = input('Enter the image name you would like to use:\n')
destination_path = input('Enter the name for the destination file (leave out .html):\n')

image = open_source_image(img_path)
pixels = image.load()
width, height = image.size

rgb_shortcuts = generate_hex_shortcuts(width, height, pixels)
mapped_rgb_shortcuts = map_hex_shortcuts_to_image(width, height, pixels, rgb_shortcuts)

rgb_css = generate_shortcut_css(rgb_shortcuts)

result = generate_html_start(width, height, rgb_css)
result += generate_html_pixels(mapped_rgb_shortcuts)
result += generate_html_end()


file = create_destination_file(destination_path)
write_to_destination_file(file, result)
